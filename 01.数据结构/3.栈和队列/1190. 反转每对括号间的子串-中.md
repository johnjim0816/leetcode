# [1190. 反转每对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)

给出一个字符串 `s`（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 **不应** 包含任何括号。 

**示例 1：**

```
输入：s = "(abcd)"
输出："dcba"
```

**示例 2：**

```
输入：s = "(u(love)i)"
输出："iloveu"
```

**示例 3：**

```
输入：s = "(ed(et(oc))el)"
输出："leetcode"
```

**示例 4：**

```
输入：s = "a(bcdefghijkl(mno)p)q"
输出："apmnolkjihgfedcbq"
```

**提示：**

- `0 <= s.length <= 2000`
- `s` 中只有小写英文字母和括号
- 我们确保所有括号都是成对出现的



```python
class Solution:
    def reverseParentheses(self,s: str) -> str:
        stack=[]
        for c in s:
            if c!=')': stack.append(c) # 左括号or字母入栈
            elif c==')': 
                temp=[] # 临时列表 用于保存翻转后子串
                while stack and stack[-1]!='(': 
                    temp.append(stack.pop())
                stack.pop() # 左括号弹出
                stack+=temp # 接上temp，即内层翻转后的字符串
        return ''.join(stack)
```


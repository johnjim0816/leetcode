#### [156. 上下翻转二叉树](https://leetcode-cn.com/problems/binary-tree-upside-down/)

给定一个二叉树，其中所有的右节点要么是具有兄弟节点（拥有相同父节点的左节点）的叶节点，要么为空，将此二叉树上下翻转并将它变成一棵树， 原来的右节点将转换成左叶节点。返回新的根。

**例子:**

```
输入: [1,2,3,4,5]

    1
   / \
  2   3
 / \
4   5

输出: 返回二叉树的根 [4,5,2,#,#,3,1]

   4
  / \
 5   2
    / \
   3   1  
```

**说明:**

对 `[4,5,2,#,#,3,1]` 感到困惑? 下面详细介绍请查看 [二叉树是如何被序列化的](https://support.leetcode-cn.com/hc/kb/article/1194353/)。

二叉树的序列化遵循层次遍历规则，当没有节点存在时，'#' 表示路径终止符。

这里有一个例子:

```
   1
  / \
 2   3
    /
   4
    \
     5
```

上面的二叉树则被序列化为 `[1,2,3,#,#,4,#,#,5]`.



规律是：左子节点变父节点；父节点变右子节点；右子节点变父节点。

```python
class Solution:
    def upsideDownBinaryTree(self, root: TreeNode) -> TreeNode:
        parent = parent_right = None
        while root:
            root_left = root.left
            root.left = parent_right
            parent_right = root.right
            root.right = parent
            parent = root
            root = root_left
        return parent

# 作者：jyd
# 链接：https://leetcode-cn.com/problems/binary-tree-upside-down/solution/binary-tree-upside-down-top-downdie-dai-fa-by-jin4/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```python
class Solution:
    def upsideDownBinaryTree(self, root: TreeNode) -> TreeNode:
        if not root or not root.left:
            return root
        left = self.upsideDownBinaryTree(root.left)
        root.left.left = root.right # 右子树变成左子树
        root.left.right = root # 根变为右子树
        root.left = None
        root.right = None
        return left

# 作者：jyd
# 链接：https://leetcode-cn.com/problems/binary-tree-upside-down/solution/binary-tree-upside-down-top-downdie-dai-fa-by-jin4/
# 来源：力扣（LeetCode）
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

